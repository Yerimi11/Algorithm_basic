# 생각한 아이디어 https://chanhuiseok.github.io/posts/baek-22/ 
# 이분 탐색 문제는 무엇을 탐색할 것인지 생각하는 것이 가장 중요한 것 같습니다.

# 이 문제는 블루레이의 최소 크기를 찾는 문제입니다.
# 그리고 조건을 하나씩 살펴봐야 합니다. 이 과정에서 시간이 꽤 걸렸던 것 같습니다.
# 과정을 하나씩 천천히 살펴보도록 하겠습니다.

# 먼저, 각 레슨을 블루레이 내에 순서대로 담아야 하는 조건이 있습니다.
# 그리고 만약 블루레이 크기가 10이었다고 가정해 보겠습니다.
# 9 3
# 1 2 3 4 5 6 7 8 9
# 이러한 인풋이 들어왔을 때, 앞에서부터 레슨을 더해 봅니다.

# 1 + 2 + 3 + 4 = 10 입니다. 여기에 5까지 더하면 15가 되어버립니다.

# 즉, 하나의 블루레이에 1부터 5까지는 들어갈 수 없고, 1부터 4까지만 들어갈 수 있습니다.
# 그러면 블루레이 1번에 1부터 4까지의 레슨을 담았습니다.

# 나머지 레슨에 대해서도 진행해 보겠습니다.
# 5 + 6 = 11이므로, 블루레이 크기를 초과해 버립니다. 따라서 블루레이 2번에는 레슨 5만 들어갑니다.
# 6, 7, 8, 9 에 대해서도 블루레이 1개에 각각 1개씩만 담기가 가능합니다.

# 따라서 레슨이 담긴 구성은 다음과 같아집니다.
# {1, 2, 3, 4}, {5}, {6}, {7}, {8}, {9} = 총 블루레이 갯수 6개

# 그런데 인풋에서는 블루레이 갯수가 3개로 주어졌습니다. 즉, 이러한 구성은 답이 될 수 없습니다.
# 따라서 블루레이 크기를 10이 아니라, 좀 더 늘려야겠다는 결론을 얻을 수 있습니다.
# 이렇게 임의의 블루레이 크기를 정하여 담아 본 다음, 블루레이 갯수가 인풋에서 제한한 갯수보다 많아지면 블루레이 크기를 늘려야겠고, 
# 적어지면 블루레이 크기를 줄여봐야 겠다는 생각을 할 수 있습니다. 이 부분을 이분탐색하면 됩니다.

# 이분탐색에서 left, right(low, high)를 정해야 할 텐데, 우선 right(high), 제일 극단적인 끝값은 모든 레슨의 길이를 더한 값이 될 것입니다.
# 1 2 3 4 5 6 7 8 9 의 인풋을 다 더하면 45입니다. 블루레이 하나의 크기가 45라면, 블루레이 1개에 모든 레슨을 다 담을 수 있습니다.
# 그러면 맨 왼쪽 끝값은 어떤 값이 되어야 할까요?
# 블루레이 하나의 크기가 만약 1이었을 경우, 레슨 1만 담을 수 있고 나머지는 모두 담을 수 없습니다.
# 이러면 문제의 조건에 어긋나게 됩니다. 모든 레슨들을 블루레이에 담아야 하기 때문입니다.
# 따라서 레슨 중 크기가 가장 큰 9의 값이 왼쪽 끝값이 되어야 할 것입니다.
# 블루레이 크기가 9라면, 모든 레슨들을 블루레이에 담을 수는 있기 때문입니다.

# 소스코드
# 초기 low, high 값을 각각 위에서 말한 대로 초기화 하였습니다.
# 이 때 mid = (low + high) / 2 값이 임시로 가정할 블루레이의 크기가 될 것입니다.
# for문을 이용해 모든 레슨들을 하나씩 담아 보면서, 그 합이 mid 값보다 커진다면 필요한 블루레이 갯수를 한개 증가시켜 줍니다. 위에서 말했던 과정들과 동일합니다.
# 그리고 담은 레슨들 말고 그 다음부터 다시 또 담아 보면서 합을 구합니다.
# 이를 끝까지 반복한 뒤, 만약 구한 블루레이 갯수가 M보다 적다면 블루레이 1개당 크기를 줄여야겠고, 블루레이 갯수가 M보다 많다면 블루레이 1개당 크기를 늘려야 할 것입니다.
# 이것이 코드상에서 low = mid+1 이나 high = mid - 1로 조정하는 부분입니다.
# 최종적인 답은 low 에 담겨 있을 것입니다.








# ------------------------------------------------------------------------------
# 이 문제는 이분 탐색(Binary Search) 문제이다.
# 주어진 기타 레슨을 M개 이하의 구역으로 분리하는 블루레이 크기 중 최솟값을 출력하면 된다.

# 이분 탐색을 진행하기 위해서 Left, Right를 아래와 같이 초기화하였다.
# Left = sum(기타 레슨) // M    => left  15 = 45%3
# Right = sum(기타 레슨)        => right 45
# answer(최종답) = Right       => answer 45


# 위 과정을 진행한 후 본격적인 이분 탐색 과정은 다음과 같다.
# 1. mid값을 구한다. (left + right) // 2        => mid 30 = (15+45)//2
# 2. mid값이 기타 레슨의 최댓값보다 작은지 판단한다.
#    -  작다면 기타 레슨을 담을 수 없으므로 left = mid + 1로 업데이트한다.          => left 31
# 3. mid값으로 기타 레슨을 M개 이하의 구역으로 나눌 수 있는지 판단한다.               => 31 % 3 쌉가능
#    - 나눌 수 있다면 더 작은 값을 판단하기 위해서 right = mid - 1로 업데이트한다.   => right 29
#    - answer값보다 mid값이 작다면 answer를 mid로 업데이트한다.                 => answer 30
#    - 나눌 수 없다면 더 큰 값을 판단하기 위해서 left = mid + 1로 업데이트한다.

# if __name__ == "__main__":

#     N, M = map(int, input().split())
#     arr = list(map(int, input().split()))

#     lesson_total = sum(arr)
#     left, right = lesson_total // M, sum(arr)
#     # print(left, right)
#     answer = right
#     while left <= right:
#         mid = (left + right) // 2

#         if mid < max(arr):
#             left = mid + 1
#             continue
#         # 조건 만족 확인
#         count, temp = 0, 0
#         for i in range(len(arr)):
#             if arr[i] > mid:
#                 break
#             elif temp + arr[i] <= mid:
#                 temp += arr[i]
#             else:
#                 temp = arr[i]
#                 count += 1

#         if count <= M - 1:  # 가능한 경우 (더 작은 값이 있는지 확인해야 한다)
#             right = mid - 1
#             answer = min(answer, mid)  # answer 값 업데이트
#         else:  # 값을 증가시켜야 한다.
#             left = mid + 1

#     print(answer)
